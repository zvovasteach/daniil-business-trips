import { createTestingPinia, type TestingOptions } from '@pinia/testing';
import { VueQueryPlugin } from '@tanstack/vue-query';
import { render, type RenderOptions } from '@testing-library/vue';
import { type ComponentMountingOptions, shallowMount } from '@vue/test-utils';
import { mount } from '@vue/test-utils';
import { cloneDeep, isArray, mergeWith } from 'lodash-es';
import type { App, Plugin } from 'vue';
import {
  createRouter,
  createWebHistory,
  type RouteLocationRaw,
  type Router,
  type RouteRecordRaw,
  type RouterOptions,
} from 'vue-router';

import { RouteName } from '@/common/constants/route-name.ts';
import { i18n } from '@/plugins/i18n.ts';
import { testRoutes } from '~/autogenerated/test-routes.ts';

const deep = (a: unknown, b: unknown) => {
  if (isArray(a) && isArray(b)) {
    return [...a, ...b];
  }
};

interface WrapperOptions<T> {
  props?: ComponentMountingOptions<T>['props'];
  slots?: ComponentMountingOptions<T>['slots'];
  global?: ComponentMountingOptions<T>['global'];
}

const defaultRoutes = testRoutes as unknown as RouteRecordRaw[];

export class ComponentMounter<T> {
  readonly #component: T;
  #router: Router | null = null;
  #initialRoute: RouteLocationRaw = { name: RouteName.HOME };
  #defaultPiniaOptions: TestingOptions | null = null;
  #disposablePiniaOptions: TestingOptions | null = null;
  #hasTanStack = false;
  readonly #additionalOptions: Parameters<typeof mount<T>>[1] = {
    global: {
      stubs: {
        teleport: true,
        skeletor: { template: '<div>Skeletor</div>' },
        AnimationLoader: { template: '<div>AnimationLoaderMock</div>' },
        AnimationProgressBar: { template: '<div>AnimationProgressBarMock</div>' },
        AnimationSuccess: { template: '<div>AnimationSuccessMock</div>' },
      },
    },
  };

  constructor(
    component: T,
    defaultOptions: WrapperOptions<T> | null = null,
  ) {
    this.#component = component;
    if (defaultOptions) {
      mergeWith(this.#additionalOptions, defaultOptions, deep);
    }
  }

  public addRouter = (options: {
    initialRoute?: RouteLocationRaw;
    routerOptions?: RouterOptions;
  } = {}) => {
    const { initialRoute, routerOptions } = options;
    if (initialRoute) {
      this.#initialRoute = initialRoute;
    }
    this.#router = createRouter({
      history: createWebHistory(),
      routes: routerOptions?.routes
        ?? defaultRoutes as unknown as RouteRecordRaw[],
    });
    return this;
  };

  resetRouter = async () => {
    if (!this.#router) {
      throw new Error('Router is not set');
    }
    await this.#router.push(this.#initialRoute);
    await this.#router.isReady();
  };

  get router() {
    if (!this.#router) {
      throw new Error('Router is not set');
    }
    return this.#router;
  }

  // Permanent Pinia settings
  public addPinia = (options: TestingOptions = {}) => {
    if (this.#defaultPiniaOptions) {
      throw new Error('Pinia already added');
    }
    this.#defaultPiniaOptions = options;
    return this;
  };

  // One-time Pinia settings
  public setPinia = (options: TestingOptions = {}) => {
    if (!this.#defaultPiniaOptions) {
      throw new Error('Pinia not added');
    }
    this.#disposablePiniaOptions = options;
    return this;
  };

  public addTanStack = () => {
    this.#hasTanStack = true;
    return this;
  };

  private getPlugins = async () => {
    const plugins: Plugin[] = [i18n];
    if (this.#defaultPiniaOptions) {
      plugins.push(createTestingPinia(
        this.#disposablePiniaOptions ?? this.#defaultPiniaOptions,
      ));
      this.#disposablePiniaOptions = null;
    }
    if (this.#hasTanStack) {
      plugins.push((app: App) => {
        VueQueryPlugin.install(app, {
          queryClientConfig: {
            defaultOptions: {
              queries: {
                retry: false,
                // eslint-disable-next-line camelcase
                experimental_prefetchInRender: true,
              },
            },
          },
        });
      });
    }
    if (this.#router) {
      await this.#router.push(this.#initialRoute);
      await this.#router.isReady();
      plugins.push(this.#router);
    }
    return plugins;
  };

  private getResultOptions = async (
    options: Parameters<typeof mount<T>>[1],
  ) => {
    let resultOptions = cloneDeep(this.#additionalOptions);
    const plugins = await this.getPlugins();
    resultOptions = mergeWith(resultOptions, options, deep);
    if (!resultOptions) {
      resultOptions = { global: { plugins } };
    } else if (!resultOptions.global) {
      resultOptions.global = { plugins };
    } else {
      resultOptions.global.plugins = plugins;
    }
    return resultOptions;
  };

  // Use <typeof mount<T>>[1] for a better type clue in code completion
  public render = async (
    options: Parameters<typeof mount<T>>[1] = {},
  ) => {
    const resultOptions = await this.getResultOptions(options);
    return render(this.#component, resultOptions as RenderOptions<T>);
  };

  public shallowRender = async (
    options: Parameters<typeof mount<T>>[1] = {},
  ) => {
    const resultOptions = await this.getResultOptions(options);
    resultOptions.shallow = true;
    return render(this.#component, resultOptions as RenderOptions<T>);
  };

  public mount = async (
    options: Parameters<typeof mount<T>>[1] = {},
  ) => {
    const resultOptions = await this.getResultOptions(options);
    return mount(this.#component, resultOptions);
  };

  public shallowMount = async (
    options: Parameters<typeof mount<T>>[1] = {},
  ) => {
    const resultOptions = await this.getResultOptions(options);
    return shallowMount(this.#component, resultOptions);
  };
}
